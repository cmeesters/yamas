# Copyright (C) 2010-2011, Christian Meesters (meesters@uni-mainz.de)
# This code is part of the yamas distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.

# $Rev: 940 $
# $LastChangedDate: 2014-08-30 12:57:41 +0200 (Sa, 30 Aug 2014) $ # date of last revision
# $Author: meesters $

from datetime import datetime
import fnmatch
import hashlib
import zipfile
import tarfile
import platform
import subprocess
import os
import glob
import re
import shutil
import tempfile
import warnings
import sys

os.nice(10)

# shortcut
LS = os.linesep

VERSION = ("1", "4", "3")
VERSIONSTRING = '.'.join(VERSION)
DATE    = datetime.today().strftime("%d. %b %Y")

def write_doxygencfg():
    tmpfname = tempfile.mktemp()
    tmpfile = open(tmpfname, 'w')
    infile  = open("doxygen_yamas.cfg")
    for line in infile:
	if "PROJECT_NUMBER" in line:
            tmpfile.write("PROJECT_NUMBER = %s" % VERSIONSTRING)
	    tmpfile.write(os.linesep)
	else:
            tmpfile.write(line)
    infile.close()
    tmpfile.close()
    shutil.move(tmpfname, 'doxygen_yamas.cfg')

def write_versionheader():
    """
       will write the version header file,
       just before compilation
    """
    # retrieve revision number
    revision = subprocess.Popen(['svnversion'], stdout=subprocess.PIPE).communicate()[0]
    # gcc version tuple
    gcc_version = ','.join(['__GNUC__', '__GNUC_MINOR__', '__GNUC_PATCHLEVEL__'])

    versionfile = open('./trunk/include/ya_version.hpp', 'w')
    versionfile.write("// This file is automatically generated -- do not try to change it." + LS)
    versionfile.write("// The YAMAS license applies." + LS + LS)
    versionfile.write("#include \"boost/tuple/tuple.hpp\"%s" % LS)
    versionfile.write("#include <string> %s" % LS)
    versionfile.write("#include <map> %s" % LS)
    versionfile.write("// yamas version tuple: major, minor, bug fix %s" % LS)
    versionfile.write("typedef boost::tuple<int, int, int> version;%s" % LS)
    versionfile.write("#ifdef __GNUC__ %s  typedef boost::tuple<int, int, int> gcc_version;%s#endif%s" % (LS, LS, LS))
    versionfile.write(LS)
    versionfile.write('namespace yamas {%s \
    const version VERSION(%s);%s \
    const std::string DATE(\" %s\");%s \
    const std::string REVISION(\"%s\");%s \
    #ifdef __GNUC__ %s\
      const gcc_version GCC_VERSION(%s);%s \
    #endif %s\
} // end namespace yamas%s' % (LS, ','.join(VERSION), LS, DATE, LS, revision.rstrip(), LS, LS, gcc_version, LS, LS, LS))

def check_gcc_version():
    g_comp = GetOption('CXX')
    ret = subprocess.Popen(['%s --version' % g_comp], 
                           stdout = subprocess.PIPE,
                           stderr = subprocess.PIPE, 
                           shell = True).communicate()[0]
    version_string = re.search(r'\d\.\d\.\d', ret).group()
    return tuple(map(int, version_string.split('.')))

Help("""
       yamas build setup
       Type: 'scons'                to build the production program,
             'scons --debug_build'  to build the debug version with gcc profiling,
             'scons --pack_release' to build and package the release version,
             'scons --doxygen'      to call doxygen (only if doxygen is present),
             'scons --static'       to statically link the program,
             'scons --compiler=<compiler>' to activly choose a different compiler,
             'scons --include_production' to set the INCLUDE_PRODUCTION flag,
             'scons --sandbox'            to set the SANDBOX flag,
             'scons --lib'          to alter the LIBRARY_PATH on the fly.
       Using '-j x', where 'x' is the number of processes to use,
       enables parallel building.
       """)

src_files = Glob('trunk/src/*cpp')

AddOption('--debug_build',
          dest    = 'yamas_debug',
          action  = 'store_true',
          default = False,
          help    = 'build a debug version')

AddOption('--pack_release',
          dest    = 'pack_release',
          action  = 'store_true',
          default = False,
          help    = 'build and pack a release to be shipped')

AddOption('--doxygen',
          dest    = 'doxygen',
	  action  = 'store_true',
	  default = False,
	  help    = 'replaces the doxygen.cfg file and calls doxygen')

AddOption('--static',
          dest    = 'static',
          action  = 'store_true',
	  default = False)
AddOption('--test',
          dest    = 'test',
	  action  = 'store_true',
	  default = False)
AddOption('--test_debug',
          dest    = 'testdebug',
	  action  = 'store_true',
	  default = False)
AddOption('--test_memory',
          dest    = 'testmemory',
          action  = 'store_true',
          default = False,
          help    = 'turns on memory profiling for gcc on some(!) Linux systems')
AddOption('--compiler',
          dest    = 'CXX',
          default = 'g++')
AddOption('--libpath',
          dest    = 'lib')
AddOption('--sandbox',
          action  = 'store_true',
          default = False,
          dest    = 'sandbox',
          help    = "will include sandboxed code, currently demands the MGL library")
AddOption('--include_production',
          action  = 'store_true',
          default = False,
          dest    = 'include_production',
          help    = "will include all production code, including LD-blockwise algorithm")
AddOption('--timer',
          action  = 'store_true',
          default = False,
          dest    = 'timer',
          help    = "will enable timings")

opt = Environment(ENV  = os.environ,
                  PATH = os.environ['PATH'],
                  TERM = os.environ['TERM'],
                  HOME = os.environ['HOME'],
                  CXX  = GetOption('CXX'))

if GetOption('doxygen'):
   write_doxygencfg()
   subprocess.call('doxygen doxygen_yamas.cfg', shell = True)
   sys.exit()

# configure C++11 support for g++
C11 = "-std=c++0x"
if check_gcc_version() >= (4, 7):
   C11 = "-std=c++11"

if GetOption('yamas_debug'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-pg'])
   ccflags = ['-fopenmp', '-Wall', 
              '-g',         # let the program write GNU debugger output
              '-pg',        # enables profiling
              C11,          # C11 compliance
	      '-DDEBUG']    # sets the DEBUG-flag for the preprocessor
elif GetOption('pack_release'): # in this case a static executable is handy
   opt.Append(LINKFLAGS = ['-fopenmp', '-static'])
   ccflags = ['-fopenmp', '-O3', '-Wall', '-ansi', '-pedantic',
               C11]
elif GetOption('testdebug'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-pg'])
   ccflags = ['-fopenmp', '-O0', '-Wall', '-ansi', '-pedantic',
              C11, '-DTEST', '-DDEBUG', '-g', '-pg']
else:
   opt.Append(LINKFLAGS = ['-fopenmp'])
   ccflags = ['-fopenmp', '-O2', '-Wall', '-ansi', '-pedantic',
               C11]

if GetOption('sandbox'):
   ccflags.append('-DSANDBOX')
if GetOption('timer'):
   ccflags.append('-DTIMER')
if GetOption('include_production'):
   ccflags.append('-DINCLUDEPRODUCTION')
if GetOption('testmemory'):
   ccflags.append('-DMEMORY')
if GetOption('test'):
   ccflags.append('-DTEST')

if GetOption('static'):
   opt.Append(LINKFLAGS = ['-static'])
   #ccflags.append('-DSIMULATION')
if GetOption('lib'):
   try:
       LIBPATH = os.environ['LIBRARY_PATH']
       LIBPATH.append(GetOption('lib'))
   except KeyError:
       LIBPATH = []
else:
   try:
       LIBPATH = os.environ['LIBRARY_PATH']
   except KeyError:
       LIBPATH = []

if __name__ == "SCons.Script": 
    # check whether minimum gcc version is supported on this machine
    # if g++ is actually installed
    if 'g++' in GetOption('CXX'): 
        if not check_gcc_version() >= (4, 4):
            raise AssertionError("YAMAS requires g++ >= 4.4 to compile")
    else:
        warnings.warn("Assuming compiler != g++. Please ensure that OpenMP 3 is supported.")
    write_versionheader()

    # Decide whether file has changed and needs rebuilding in the
    # development process
    Decider('MD5') # default is md5
    
    if GetOption('sandbox'):
        src_files.extend(Glob('trunk/sandbox/src/*cpp'))
        opt.Program(target  = './yamas', 
                    source  = src_files, 
	            CCFLAGS = ccflags, 
                    LIBPATH = LIBPATH,
	            LIBS    = ['libboost_program_options',
                               'libboost_iostreams',
                               'mgl',
                               'png',
                               'z'])
    else:
        opt.Program(target  = './yamas', 
                    source  = src_files, 
	            CCFLAGS = ccflags, 
                    LIBPATH = LIBPATH,
	            LIBS    = ['libboost_program_options',
                               'libboost_iostreams',
                               'z'])

    if GetOption('pack_release'):
        print "Packing release"
    
        # create 'dist' directory
        try:
            os.mkdir('dist')
        except OSError: pass
        os.chdir('dist')

        ARCHITECTURE = platform.architecture()[0]
        SYSTEM       = platform.system()

        # list of tuples: (location, naming after unpacking)
        file_list = [('../yamas', './yamas_%s/yamas' % VERSIONSTRING),
                     ('../LICENSE', './yamas_%s/LICENSE' % VERSIONSTRING),
                     ('../INSTALL', './yamas_%s/INSTALL' % VERSIONSTRING),
                     ('../utilities/forest_plot.py', './yamas_%s/utilities/forest_plot' % VERSIONSTRING),
                     ('../utilities/switch_marker.py', './yamas_%s/utilities/switch_marker' % VERSIONSTRING),
                     ('../utilities/vcf2tped.py', './yamas_%s/utilities/vcf2tped' % VERSIONSTRING),
                     ('../utilities/convert_FAMHAP.py', './yamas_%s/utilities/convert_FAMHAP' % VERSIONSTRING),
                     ('../utilities/README', './yamas_%s/utilities/README' % VERSIONSTRING),
                     ('../examples/yamas.cfg', './yamas_%s/examples/yamas.cfg' % VERSIONSTRING),
                     ('../examples/README', './yamas_%s/examples/README' % VERSIONSTRING),
                     ('../examples/study_01.assoc', './yamas_%s/examples/study_01.assoc' %  VERSIONSTRING),
                     ('../examples/study_02.assoc', './yamas_%s/examples/study_02.assoc' %  VERSIONSTRING),
                     ('../examples/study_03.assoc', './yamas_%s/examples/study_03.assoc' %  VERSIONSTRING),
                     ('../doc/Manual.pdf', './yamas_%s/doc/Manual.pdf' % VERSIONSTRING)]

        # first make source distro
        sourcetarfname = 'yamas_%s_source.tar' % VERSIONSTRING
        cppdir   = '../trunk/src'
        libdir   = '../trunk/include'
        curdir   = os.getcwd()
        t = tarfile.TarFile(sourcetarfname, 'w')
        
        # add actual sources
        os.chdir(cppdir)
        for fname in glob.glob('*cpp'):
            t.add(fname, "./yamas_%s/trunk/src/%s" % (VERSIONSTRING, fname))
        os.chdir(curdir)

        # add header files
        os.chdir(libdir)
        for fname in glob.glob('*hpp'):
            t.add(fname, "./yamas_%s/trunk/include/%s" % (VERSIONSTRING, fname))
        os.chdir(curdir)
        for fname in glob.glob('../utilities/*'):
            tail = os.path.split(fname)[-1]
            t.add(fname, "./yamas_%s/utilities/%s" % (VERSIONSTRING, tail))
        for fname in glob.glob('../doc/*.tex'):
            tail = os.path.split(fname)[-1]
            t.add(fname, "./yamas_%s/doc/%s" % (VERSIONSTRING, tail))
        t.add('../doc/Manual.pdf', "./yamas_%s/doc/Manual.pdf" % VERSIONSTRING)
        for fname in ['../doxygen_yamas.cfg', '../LICENSE', '../SConstruct', '../INSTALL']:
            tail = os.path.split(fname)[-1]
            t.add(fname, "./yamas_%s/%s" % (VERSIONSTRING, tail))
        t.close()
        subprocess.call(['gzip', '-f9', sourcetarfname])

        buildzipfname = 'yamas_%s_%s_%s.zip' % (ARCHITECTURE, SYSTEM, VERSIONSTRING)
        z = zipfile.ZipFile(buildzipfname, 'w', compression = zipfile.ZIP_DEFLATED)
        for item in file_list:
            z.write(item[0], item[1])
        z.close()

        if platform.system() == 'Linux':
            buildtarfname = 'yamas_%s_%s_%s.tar' % (ARCHITECTURE, SYSTEM, VERSIONSTRING)
            t = tarfile.TarFile(buildtarfname, 'w')
            for item in file_list:
                t.add(item[0], item[1])
            t.close()
            subprocess.call(['gzip', '-f9', buildtarfname])

        # calculate md5sums
        print "Calculating md5sums"
        sep = os.linesep
        md5file = open("md5sums.txt", 'a')
        md5file.write("Source distribution: ")
        content = open("%s.gz" % sourcetarfname).read()
        md5source = hashlib.md5()
        md5source.update(content)
        md5file.write(md5source.hexdigest() + sep)
        md5file.write("Zipfile %s: " % buildzipfname)
        content = open(buildzipfname).read()
        md5zip = hashlib.md5()
        md5zip.update(content)
        md5file.write(md5zip.hexdigest() + sep)
        md5file.write("Tarfile %s.gz: " % buildtarfname)
        content = open("%s.gz" % buildtarfname).read()
        md5tar = hashlib.md5()
        md5tar.update(content)
        md5file.write(md5tar.hexdigest() + sep)

        md5file.close()
        print     

        os.chdir('../')
        print "Finished packing release"
        sys.exit()
    
